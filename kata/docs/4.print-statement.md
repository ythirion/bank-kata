## Print Statement
Let's think about test cases for the PrintStatement:
```text
Not existing account -> return a failure "Unknown account"
Existing account without transactions -> print an empty statement (only headers)
Existing account with transactions (+20 078.89, -5890.87, +3678.54) -> print the statement in reverse chronological order 
```

Let's create a new test class `PrintStatementShould`

### Non-passing tests
:red_circle: Let's write our first test (Not existing account -> return a failure "Unknown account")

```scala
class PrintStatementShould
    extends AnyFlatSpec
    with AccountUseCaseTest
    with MockFactory
    with EitherValues
    with Matchers
    with OneInstancePerTest {

  private val printerStub = stubFunction[String, Unit]
  private val printStatementUseCase = new PrintStatementUseCase(accountRepositoryStub, printerStub)

  it should "return a failure for a non existing account" in {
    notExistingAccount()
    printStatementUseCase
      .invoke(PrintStatement(anAccountId))
      .left
      .get mustBe "Unknown account"
  }
}
```

:green_circle: We need to adapt our UseCase to make it return an `Either[String, Unit]`
```scala
class PrintStatementUseCase(accountRepository: AccountRepository, printer: String => Unit) {
  def invoke(printStatement: PrintStatement): Either[String, Unit] =
    Left("Unknown account")
}
```

```text
âœ… Not existing account -> return a failure "Unknown account"
Existing account without transactions -> print an empty statement (only headers)
Existing account with transactions (+20 078.89, -5890.87, +3678.54) -> print the statement in reverse chronological order 
```

### Passing tests
:red_circle: Let's write a passing test now (Existing account without transactions -> print an empty statement (only headers))
We will need to:
- Fetch the Account from the database
- Format a statement for it

We should separate formatting logic from the account management logic -> create a `StatementFormatter`
- You can see it as a new `port` in our domain
- Its adapter can be a `ConsoleFormatter` (the one required for our acceptance test)

```scala
private val printerStub = stubFunction[String, Unit]
  private val statementFormatter = ConsoleFormatter()
  private val printStatementUseCase =
      new PrintStatementUseCase(
        accountRepositoryStub,
        printerStub,
        statementFormatter
      )

  ...

  it should "print an empty statement (only headers) for an existing account without transactions" in {
    existingAccount()

    printStatementUseCase
      .invoke(PrintStatement(anAccountId))
      .isRight mustBe true

    printerStub.verify("date       |   credit |    debit |  balance").once()
  }
```

:green_circle: We adapt the use case to pass the new parameter.

- We create a trait/port for `StatementFormatter`
- We create the `ConsoleFormatter` in a `banking.adapters` package
- We use it in the UseCase and `Account` class

```scala
trait StatementFormatter {}
case class ConsoleFormatter() extends StatementFormatter {}

class PrintStatementUseCase(
    accountRepository: AccountRepository,
    printer: String => Unit,
    statementFormatter: StatementFormatter
) {
  def invoke(printStatement: PrintStatement): Either[String, Unit] =
    accountRepository.find(printStatement.accountId) match {
      case Some(account) =>
        Right(
          printer(account.toStatement(statementFormatter))
        )
      case None => Left("Unknown account")
    }
}

case class Account(id: UUID, transactions: List[Transaction] = List()) {
  ...
  def toStatement(statementFormatter: StatementFormatter): String =
    statementFormatter.format(
      transactions.sortBy(_.at.toEpochSecond(ZoneOffset.UTC))
    )
}
```

Then implement the `ConsoleFormatter`

```scala
case class ConsoleFormatter() extends StatementFormatter {
  override def format(transactions: List[Transaction]): String =
    "date       |   credit |    debit |  balance"
}
```

:large_blue_circle: Remove duplication between Use Cases

We always have the same logic in our 3 Use Cases for `Account` that could be centralized.
```scala
accountRepository.find(printStatement.accountId) match {
      case Some(account) => <call a method>
      case None => Left("Unknown account")
    }
```

Let's isolate this logic in a trait and use it in our Use Cases
```scala
trait AccountUseCase {
  protected def invokeWhenAccountExists[TResult](
      accountRepository: AccountRepository,
      accountId: UUID,
      onSuccess: Account => Either[String, TResult]
  ): Either[String, TResult] =
    accountRepository.find(accountId) match {
      case Some(account) => onSuccess(account)
      case None          => Left("Unknown account")
    }
}

class WithdrawUseCase(accountRepository: AccountRepository, clock: Clock)
    extends AccountUseCase {
  def invoke(withdraw: Withdraw): Either[String, Account] =
    invokeWhenAccountExists(
      accountRepository,
      withdraw.accountId,
      account => withdrawSafely(withdraw, account)
    )
    ...clock
}

class PrintStatementUseCase(
    accountRepository: AccountRepository,
    printer: String => Unit,
    statementFormatter: StatementFormatter
) extends AccountUseCase {
  def invoke(printStatement: PrintStatement): Either[String, Unit] = 
    invokeWhenAccountExists(
      accountRepository,
      printStatement.accountId,
      account =>
        Right(
          printer(account.toStatement(statementFormatter))
        )
    )
}

class DepositUseCase(accountRepository: AccountRepository, clock: Clock)
    extends AccountUseCase {
  def invoke(deposit: Deposit): Either[String, Account] =
    invokeWhenAccountExists(
      accountRepository,
      deposit.accountId,
      account => depositSafely(deposit, account)
    )
    ...
}
```
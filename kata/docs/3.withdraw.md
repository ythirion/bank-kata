## Withdraw
Let's think about test cases for the withdraw:
```text
Not existing account -> return a failure "Unknown account"
Existing account -> return a failure for a withdraw of 0
Existing account with not enough money & a withdraw of 100 -> return a failure because "not enough money available" 
Existing account with enough money & a withdraw of 900 -> store the updated account containing a negative transaction of 900
```

Let's create a new test class `WithdrawShould`

### Non-passing tests
:red_circle: Let's write our first test (Not existing account -> return a failure "Unknown account")

```scala
class WithdrawShould
    extends AnyFlatSpec
    with MockFactory
    with EitherValues
    with Matchers
    with OneInstancePerTest {
  private val anAccountId = UUID.randomUUID()
  private val accountRepositoryStub = stub[AccountRepository]
  private val withdrawUseCase = new WithdrawUseCase()

  it should "return a failure for a non existing account" in {
    notExistingAccount()
    withdrawUseCase
      .invoke(Withdraw(anAccountId, 100))
      .left
      .get mustBe "Unknown account"
  }

  private def notExistingAccount(): Unit =
    (accountRepositoryStub.find _)
      .when(anAccountId)
      .returns(None)
}
```

:green_circle: We need to adapt our UseCase to make it return an `Either[String, Account]`
```scala
class WithdrawUseCase() {
  def invoke(withdraw: Withdraw): Either[String, Account] =
    Left("Unknown account")
}
```

```text
✅ Not existing account -> return a failure "Unknown account"
Existing account -> return a failure for a withdraw of 0
Existing account with not enough money & a withdraw of 100 -> return a failure because "not enough money available" 
Existing account with enough money & a withdraw of 900 -> store the updated account containing a negative transaction of 900
```

:large_blue_circle: We have use some copy / paste for this test
Let's centralize some useful code shared between tests through a `trait`

```scala
trait AccountUseCaseTest extends MockFactory {
  protected val anAccountId: UUID = UUID.randomUUID()
  protected val accountRepositoryStub: AccountRepository =
    stub[AccountRepository]

  protected def notExistingAccount(): Unit =
    (accountRepositoryStub.find _)
      .when(anAccountId)
      .returns(None)

  protected def existingAccount(transactions: Transaction*): Unit =
    (accountRepositoryStub.find _)
      .when(anAccountId)
      .returns(
        Some(
          AccountBuilder
            .aNewAccount(anAccountId)
            .containing(transactions.toList)
            .build()
        )
      )
}
```

:red_circle: Let's add another test(Existing account -> return a failure for a withdraw of 0)
```scala
  it should "return a failure for an existing account and a withdraw of <= 0" in {
    existingAccount()
    assertErrorForNegativeOrEqualTo0Amount(0, -1, -1000, NegativeInfinity)
  }

  private def assertErrorForNegativeOrEqualTo0Amount(
      invalidAmounts: Double*
  ): Unit =
    invalidAmounts.foreach { invalidAmount =>
      withdrawUseCase
        .invoke(Withdraw(anAccountId, invalidAmount))
        .left
        .get mustBe "Invalid amount for withdraw"
    }
```

:green_circle: We adapt the use case to pass the repository instance and implement basic pattern matching
```scala
class WithdrawUseCase(accountRepository: AccountRepository) {
  def invoke(withdraw: Withdraw): Either[String, Account] =
    accountRepository.find(withdraw.accountId) match {
      case Some(account) => Left("Invalid amount for withdraw")
      case None          => Left("Unknown account")
    }
}
```

```text
✅ Not existing account -> return a failure "Unknown account"
✅ Existing account -> return a failure for a withdraw of 0
Existing account with not enough money & a withdraw of 100 -> return a failure because "not enough money available" 
Existing account with enough money & a withdraw of 900 -> store the updated account containing a negative transaction of 900
```

:large_blue_circle: We can centralize the way we assert non-passing test cases for invalid amount
```scala
trait AccountUseCaseTest extends MockFactory with Matchers {
  ...
  protected def assertErrorForNegativeOrEqualTo0Amount[TCommand](
      commandFactory: Double => TCommand,
      useCase: TCommand => Either[String, Account],
      expectedMessage: String,
      invalidAmounts: Double*
  ): Unit =
    invalidAmounts.foreach { invalidAmount =>
      useCase(commandFactory(invalidAmount)).left.get mustBe expectedMessage
    }
}
```

And to use it
```scala
  it should "return a failure for an existing account and a withdraw of <= 0" in {
    existingAccount()

    assertErrorForNegativeOrEqualTo0Amount[Withdraw](
      invalidAmount => Withdraw(anAccountId, invalidAmount),
      withdraw => withdrawUseCase.invoke(withdraw),
      "Invalid amount for withdraw",
      0,
      -1,
      -1000,
      NegativeInfinity
    )
  }
```

:red_circle: Let's add another test(Existing account with not enough money & a withdraw of 100 -> return a failure because "not enough money available" )
```scala
  it should "return a failure because not enough money available for an existing account with not enough money & a withdraw of 100" in {
    existingAccount()

    withdrawUseCase
      .invoke(createWithdrawCommand(100))
      .left
      .get mustBe "Not enough money to withdraw 100.0"
  }
```

:green_circle: We adapt the use case to delegate business logi to the `Account`

```scala
class WithdrawUseCase(accountRepository: AccountRepository) {
  def invoke(withdraw: Withdraw): Either[String, Account] =
    accountRepository.find(withdraw.accountId) match {
      case Some(account) => account.withdraw(withdraw.amount)
      case None          => Left("Unknown account")
    }
}
```

And implement `withdraw` behavior

```scala
  def withdraw(amount: Double): Either[String, Account] = {
    if (amount <= 0) Left("Invalid amount for withdraw")
    else Left(s"Not enough money to withdraw $amount")
  }
```

```text
✅ Not existing account -> return a failure "Unknown account"
✅ Existing account -> return a failure for a withdraw of 0
✅ Existing account with not enough money & a withdraw of 100 -> return a failure because "not enough money available" 
Existing account with enough money & a withdraw of 900 -> store the updated account containing a negative transaction of 900
```

:large_blue_circle: Any refactoring?
